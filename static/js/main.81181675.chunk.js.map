{"version":3,"sources":["components/Prediction.js","components/Detection.js","components/Header.js","App.js","index.js"],"names":["Prediction","imageSrc","predictions","canvasRef","React","useRef","Paper","style","margin","padding","Typography","ref","width","height","onClick","ctx","clearRect","canvas","font","textBaseline","drawImage","document","getElementById","forEach","prediction","x","bbox","y","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","class","textHeight","parseInt","fillRect","fillText","score","toFixed","showDetections","current","getContext","Detection","useState","model","setModel","isModelLoaded","setIsModelLoaded","setImageSrc","setPredictions","specificClass","setSpecificClass","useEffect","a","cocoSsd","base","newModel","loadModel","videoConstraints","facingMode","WebcamCapture","webcamRef","capture","useCallback","getScreenshot","audio","screenshotFormat","id","Button","Fragment","Divider","TextField","label","name","value","onChange","e","target","variant","color","marginLeft","detect","then","specificDetections","filter","p","console","log","Header","AppBar","Toolbar","App","marginTop","ReactDOM","render"],"mappings":"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","file":"static/js/main.81181675.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { Paper, Typography } from \"@material-ui/core\";\r\n\r\nconst Prediction = ({ imageSrc, predictions }) => {\r\n  const canvasRef = React.useRef(null);\r\n\r\n  const showDetections = ctx => {\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    const font = \"24px helvetica\";\r\n    ctx.font = font;\r\n    ctx.textBaseline = \"top\";\r\n    ctx.drawImage(document.getElementById(\"webcamFeed\"), 0, 0);\r\n\r\n    predictions.forEach(prediction => {\r\n      const x = prediction.bbox[0];\r\n      const y = prediction.bbox[1];\r\n      const width = prediction.bbox[2];\r\n      const height = prediction.bbox[3];\r\n      // Draw the bounding box.\r\n      ctx.strokeStyle = \"#2fff00\";\r\n      ctx.lineWidth = 1;\r\n      ctx.strokeRect(x, y, width, height);\r\n      // Draw the label background.\r\n      ctx.fillStyle = \"#2fff00\";\r\n      const textWidth = ctx.measureText(prediction.class).width;\r\n      const textHeight = parseInt(font, 10);\r\n      // draw top left rectangle\r\n      ctx.fillRect(x, y, textWidth + 10, textHeight + 10);\r\n      // draw bottom left rectangle\r\n      ctx.fillRect(x, y + height - textHeight, textWidth + 15, textHeight + 10);\r\n\r\n      // Draw the text last to ensure it's on top.\r\n      ctx.fillStyle = \"#000000\";\r\n      ctx.fillText(prediction.class, x, y);\r\n      ctx.fillText(prediction.score.toFixed(2), x, y + height - textHeight);\r\n    });\r\n  };\r\n\r\n  return (\r\n    <Paper style={{ margin: \"20px\", padding: \"20px\" }}>\r\n      <Typography>Here are the Predictions...</Typography>\r\n      <canvas\r\n        ref={canvasRef}\r\n        width={\"500px\"}\r\n        height={\"500px\"}\r\n        onClick={() => {\r\n          const ctx = canvasRef.current.getContext(\"2d\");\r\n          showDetections(ctx);\r\n        }}\r\n      />\r\n    </Paper>\r\n  );\r\n};\r\n\r\nexport default Prediction;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { Typography, Button, TextField, Divider } from \"@material-ui/core\";\r\nimport * as cocoSsd from \"@tensorflow-models/coco-ssd\";\r\nimport Webcam from \"react-webcam\";\r\nimport Prediction from \"./Prediction\";\r\n\r\nconst Detection = () => {\r\n  const [model, setModel] = useState(null);\r\n  const [isModelLoaded, setIsModelLoaded] = useState(false);\r\n  const [imageSrc, setImageSrc] = useState(null);\r\n  const [predictions, setPredictions] = useState(null);\r\n  const [specificClass, setSpecificClass] = useState(\"\");\r\n\r\n  useEffect(() => {\r\n    const loadModel = async () => {\r\n      const newModel = await cocoSsd.load({ base: \"lite_mobilenet_v2\" });\r\n      setModel(newModel);\r\n      setIsModelLoaded(true);\r\n    };\r\n    loadModel();\r\n  }, []);\r\n\r\n  const videoConstraints = {\r\n    width: 500,\r\n    height: 500,\r\n    facingMode: \"user\"\r\n  };\r\n\r\n  const WebcamCapture = () => {\r\n    const webcamRef = React.useRef(null);\r\n\r\n    const capture = React.useCallback(() => {\r\n      setImageSrc(webcamRef.current.getScreenshot());\r\n    }, [webcamRef]);\r\n\r\n    return (\r\n      <>\r\n        <Webcam\r\n          audio={false}\r\n          height={500}\r\n          ref={webcamRef}\r\n          screenshotFormat=\"image/jpeg\"\r\n          width={500}\r\n          videoConstraints={videoConstraints}\r\n          id={\"webcamFeed\"}\r\n        />\r\n        <br />\r\n        <Button onClick={capture}>Capture photo</Button>\r\n      </>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <Typography>\r\n        {!isModelLoaded ? \"Loading Model... ⌛\" : \"Model Loaded! ✅\"}\r\n      </Typography>\r\n      <WebcamCapture />\r\n      <Divider style={{ margin: \"20px\" }} />\r\n      <br />\r\n      <TextField\r\n        label=\"Specific Class\"\r\n        name=\"Specific Class\"\r\n        value={specificClass}\r\n        onChange={e => setSpecificClass(e.target.value)}\r\n        variant=\"outlined\"\r\n      />\r\n      <Button\r\n        color=\"primary\"\r\n        variant=\"contained\"\r\n        style={{ height: \"56px\", marginLeft: \"20px\" }}\r\n        onClick={() =>\r\n          model\r\n            .detect(document.getElementById(\"webcamFeed\"))\r\n            .then(predictions => {\r\n              if (specificClass === \"\") {\r\n                setPredictions(predictions);\r\n              } else {\r\n                const specificDetections = predictions.filter(\r\n                  p => p.class === specificClass\r\n                );\r\n                console.log(specificDetections);\r\n                setPredictions(specificDetections);\r\n              }\r\n            })\r\n        }\r\n      >\r\n        Predict\r\n      </Button>\r\n      <Prediction imageSrc={imageSrc} predictions={predictions} />\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default Detection;\r\n","import React from \"react\";\r\nimport { AppBar, Toolbar, Typography } from \"@material-ui/core\";\r\n\r\nconst Header = () => {\r\n  return (\r\n    <AppBar>\r\n      <Toolbar>\r\n        <Typography>\r\n          Tensorflow Object Detection webapp on ReactJS\r\n        </Typography>\r\n      </Toolbar>\r\n    </AppBar>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport { Paper } from \"@material-ui/core\";\r\nimport Detection from \"./components/Detection\";\r\nimport Header from \"./components/Header\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <React.Fragment>\r\n      <Header />\r\n      <Paper style={{ margin: \"20px\", padding: \"20px\", marginTop: \"80px\" }}>\r\n        <Detection />\r\n      </Paper>\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}